use std::fmt::format;
use std::fs::File;
use std::io::Write;
use std::path::Path;

const allow_blocks_suffix: &str = "AllowBlocks";
const no_blocks_suffix: &str = "NoBlocks";

fn header() -> String {
    r#"
// ====================================================
// Generated by {src_path}.
// DO NOT EDIT THIS FILE MANUALLY.
// ====================================================

use crate::ast::{Expr, TypeExpr, UnaryOp, BinaryOp, Binding};
use crate::ast;

grammar;

match {
    // length-2 ops
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "->",
    "=>",
} else {
    // operators
    "+",
    "-",
    "*",
    "/",
    "%",
    "!",
    "=",
    "<",
    ">",
    // brackets
    "(",
    ")",
    "{",
    "}",
    // separators
    ",",
    ";",
    ":",
    ".",
} else {
    r"\d+" => INTLIT,
} else {
    "true",
    "false",
    "fn",
    "let",
    "bool",
    "int",
    r"\w+" => IDENT,
}
    "#
    .replace("{src_path}", file!())
    .to_string()
}

fn param() -> String {
    r#"
Param: Binding = {
    <begin:@L> <name: IDENT> <ty: (":" <TypeExpr>)?> <end:@R> => Binding {
        name: String::from(name),
        ty: ty,
        span: (begin, end)
    }
}
    "#
    .to_string()
}

fn fn_expr() -> String {
    r#"
FnExpr: Expr = {
    <begin:@L> "fn" <name: IDENT> <param:Param> <ret_ty: ("=>" <TypeExpr>)?> <body:Block> <end:@R> => Expr::Func {
        param: param,
        ret_ty: ret_ty,
        body: Box::new(body),
        span: (begin, end),
    }
}
    "#.to_string()
}

fn block() -> String {
    r#"
Block: Expr = {
    "{" <e: BlockContent> "}" => e 
}
    "#
    .to_string()
}

fn block_content() -> String {
    r##"
BlockContent: Expr = {
    <begin:@L> <mut e: (<Stmt>)*> <r_pos:@R><r: (<OperatorExpr_NoBlocks>)? > <end:@R> => Expr::Seq { 
        seq: {
            if r.is_none() {
                e.push(Expr::UnitLit{span: (r_pos, r_pos)});
            } else {
                e.push(r.unwrap());
            }
            e
        },
        span: (begin, end)
    },
}
    "##
    .to_string()
}

fn primary_expr(allow_block: bool) -> String {
    r##"
PrimaryExpr_{suffix}: Expr = {
    <begin:@L> <t: IDENT> <end:@R> => Expr::Var{name: String::from(t), span: (begin, end)},
    <begin:@L> <t: INTLIT> <end:@R> => Expr::IntLit{value: t.parse::<i32>().unwrap(), span: (begin, end)},
    <begin:@L> <t: "true"> <end:@R> => Expr::BoolLit{value: true, span: (begin, end)},
    <begin:@L> <t: "false"> <end:@R> => Expr::BoolLit{value: false, span: (begin, end)},
    "(" <e: Expr> ")" => e,
    <e:FnExpr> => e,
    {block_clause}
}
"##
.replace("{suffix}", if allow_block {
            allow_blocks_suffix
        } else {
            no_blocks_suffix
        }).replace("{block_clause}", if allow_block {
            "<e: Block> => e"
        } else {
            ""
        })
}

fn prefix_op(token: &str, big_camel_name: &str, precedence: i32, suffix: &str) -> String {
    format!(
        r##"
        #[precedence(level="{precedence}")]
        <begin:@L> <op_begin:@L> "{token}" <op_end:@R> <arg: OperatorExpr_{suffix}_1> <end:@R> => Expr::UnaryOp {{
            op: UnaryOp::{big_camel_name},
            arg: Box::new(arg),
            span: (begin, end),
            op_span: (op_begin, op_end),
        }},
        "##
    )
}

fn binary_op(
    token: &str,
    big_camel_name: &str,
    precedence: i32,
    assoc: &str,
    suffix: &str,
) -> String {
    format!(
        r##"
    #[precedence(level="{precedence}")]
    #[assoc(side="{assoc}")]
    <begin:@L> <lhs: OperatorExpr_{suffix}_1> <op_begin:@L> "{token}" <op_end:@R> <rhs: OperatorExpr_{suffix}_1> <end:@R> => Expr::BinaryOp {{
        op: BinaryOp::{big_camel_name},
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
        span: (begin, end),
        op_span: (op_begin, op_end),
    }},
        "##
    )
}

fn operator_expr(allow_block: bool) -> String {
    let suffix = if allow_block {
            allow_blocks_suffix
        } else {
            no_blocks_suffix
        };
    let pos = prefix_op("+", "Pos", 200, suffix);
    let neg = prefix_op("-", "Neg", 200, suffix);
    let mul = binary_op("*", "Mul", 300, "left", suffix);
    let add = binary_op("+", "Add", 400, "left", suffix);
    format!(
r##"
    pub OperatorExpr_{suffix}_1: Expr = {{
        #[precedence(level="0")]
        <e: PrimaryExpr_{suffix}> => e,

        #[precedence(level="100")]
        #[assoc(side="right")]
        <begin:@L> <func: OperatorExpr_{suffix}_1> <arg: OperatorExpr_{suffix}_1> <end:@R> => Expr::App{{
            func: Box::new(func),
            arg: Box::new(arg),
            span: (begin, end)
        }},
        {pos}
        {neg}
        {mul}
        {add}
    }};

    pub OperatorExpr_{suffix}: Expr = {{
        <begin:@L> <first: OperatorExpr_{suffix}_1> <mut v:("," <OperatorExpr_{suffix}_1>)+> <end:@R> => Expr::Tuple {{
            elems: {{ v.insert(0, first); v}},
            span: (begin, end)
        }}
    }};
"##
    ) 
}

fn let_stmt() -> String {
    r#"
pub LetStmt: Expr = {
    <begin:@L> "let" <name: IDENT> <ty: (":" <TypeExpr>)?> "=" <expr: OperatorExpr_AllowBlocks> ";" <end:@R> => Expr::Let {
        name: name.to_string(),
        ty: ty,
        rhs: Box::new(expr),
        span: (begin, end)
    },
}
    "#.to_string()
}

fn stmt() -> String {
    r#"
pub Stmt: Expr = {
    <begin:@L> <e: LetStmt> <end:@R> => e,
    <begin:@L> <e: Block> <end:@R> => e,
    <e: OperatorExpr_NoBlocks> ";" <end:@R> => e,
}
    "#
    .to_string()
}

fn expr() -> String {
    r#"
pub Expr: Expr = {
    <e:OperatorExpr_AllowBlocks> => e,
    
}
    "#
    .to_string()
}

fn primary_ty() -> String {
    r#"
PrimaryTypeExpr: TypeExpr = {
    <begin:@L> "bool" <end:@R> => TypeExpr::Bool{span: (begin, end)},
    <begin:@L> "int" <end:@R> => TypeExpr::Int{span: (begin, end)},
    "(" <t: TypeExpr> ")" => t,
}
    "#
    .to_string()
}

fn ty() -> String {
    r#"
pub TypeExpr_1: TypeExpr = {
    #[precedence(level="0")]
    <t: PrimaryTypeExpr> => t,
    
    #[precedence(level="1")]
    #[assoc(side="right")]
    <begin:@L> <lhs:TypeExpr_1> "->" <rhs:TypeExpr_1> <end:@R> => TypeExpr::Arrow {
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
        span: (begin, end)
    },
}

pub TypeExpr: TypeExpr = {
    <begin:@L> <first: TypeExpr_1> <mut v:("," <TypeExpr_1>)+> <end:@R> => TypeExpr::Tuple {
        elems: {v.insert(0, first); v},
        span: (begin, end)
    },
}
    "#
    .to_string()
}

fn comma_sep_list() -> String {
    r#"
CommaSepList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
    "#
    .to_string()
}

pub fn syntax() -> String {
    let mut syntax = String::new();
    syntax.push_str(&header());
    syntax.push_str(&param());
    syntax.push_str(&fn_expr());
    syntax.push_str(&block());
    syntax.push_str(&block_content());
    syntax.push_str(&primary_expr(true));
    syntax.push_str(&primary_expr(false));
    syntax.push_str(&operator_expr(true));
    syntax.push_str(&operator_expr(false));
    syntax.push_str(&let_stmt());
    syntax.push_str(&stmt());
    syntax.push_str(&expr());
    syntax.push_str(&primary_ty());
    syntax.push_str(&ty());
    syntax.push_str(&comma_sep_list());
    syntax
}

pub fn syntax_to_file(path: &str) {
    let mut file = File::create(path).expect("Unable to create file");
    let syntax = syntax();
    file.write_all(syntax.as_bytes())
        .expect("Unable to write data");
}
