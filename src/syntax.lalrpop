use crate::ast::{Expr, Ty, UnaryOp, BinaryOp, Binding};
use crate::ast;

grammar;

match {
    // length-2 ops
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "->",
} else {
    // operators
    "+",
    "-",
    "*",
    "/",
    "%",
    "!",
    "=",
    "<",
    ">",
    // brackets
    "(",
    ")",
    "{",
    "}",
    // separators
    ",",
    ";",
    ":",
    ".",
} else {
    r"\d+" => INTLIT,
} else {
    "true",
    "false",
    "fn",
    "let",
    "bool",
    "int",
    r"\w+" => IDENT,
}

PrimaryExpr: Expr = {
    <begin:@L> <t: IDENT> <end:@R> => Expr::Var{name: String::from(t), span: (begin, end)},
    <begin:@L> <t: INTLIT> <end:@R> => Expr::IntLit{value: t.parse::<i32>().unwrap(), span: (begin, end)},
    <begin:@L> <t: "true"> <end:@R> => Expr::BoolLit{value: true, span: (begin, end)},
    <begin:@L> <t: "false"> <end:@R> => Expr::BoolLit{value: false, span: (begin, end)},
    "(" <e: Expr> ")" => e,
    <e:FnExpr> => e,
}

Param: Binding = {
    <begin:@L> <name: IDENT> <ty: (":" <Ty>)?> <end:@R> => Binding {
        name: String::from(name),
        ty: ty,
        span: (begin, end)
    }
}

FnExpr: Expr = {
    <begin:@L> "fn" "(" <params: CommaSepList<Param>> ")" <ret_ty: ("->" <Ty>)?> <body:CompoundExpr> <end:@R> => Expr::Func {
        params: params,
        ret_ty: ret_ty,
        body: Box::new(body),
        span: (begin, end),
    }
}

CompoundExpr: Expr = {
    "{" <e: CompoundExprContent> "}" => e 
    
}

CompoundExprContent: Expr = {
    <begin:@L> <e: (<Stmt>)* > <end:@R> => Expr::Seq { 
        seq: e,
        span: (begin, end)
    },
}

pub OperatorExpr: Expr = {
    #[precedence(level="0")]
    <e: PrimaryExpr> => e,

    #[precedence(level="100")]
    <begin:@L> <func: OperatorExpr> "(" <args: CommaSepList<Expr>> ")" <end:@R> => Expr::App{
        func: Box::new(func),
        args: args,
        span: (begin, end)
    },

    #[precedence(level="200")]
    <begin:@L> "+" <arg: OperatorExpr> <end:@R> => Expr::UnaryOp {
        op: UnaryOp::Pos,
        arg: Box::new(arg),
        span: (begin, end)
    },
    <begin:@L> "-" <arg: OperatorExpr> <end:@R> => Expr::UnaryOp {
        op: UnaryOp::Neg,
        arg: Box::new(arg),
        span: (begin, end)
    },

    #[precedence(level="300")]
    #[assoc(side="left")]
    <begin:@L> <arg1: OperatorExpr> "*" <arg2: OperatorExpr> <end:@R> => Expr::BinaryOp {
        op: BinaryOp::Mul,
        arg1: Box::new(arg1),
        arg2: Box::new(arg2),
        span: (begin, end)
    },

    #[precedence(level="400")]
    #[assoc(side="left")]
    <begin:@L> <arg1: OperatorExpr> "+" <arg2: OperatorExpr> <end:@R> => Expr::BinaryOp {
        op: BinaryOp::Add,
        arg1: Box::new(arg1),
        arg2: Box::new(arg2),
        span: (begin, end)
    },
};

pub LetStmt: Expr = {
    <begin:@L> "let" <name: IDENT> <ty: (":" <Ty>)?> "=" <expr: OperatorExpr> ";" <end:@R> => Expr::Let {
        name: name.to_string(),
        ty: ty,
        expr: Box::new(expr),
        body: (),
        span: (begin, end)
    },
}

pub Stmt: Expr = {
    <begin:@L> <e: LetStmt> <end:@R> => e,
    <begin:@L> <e: CompoundExpr> <end:@R> => e,
    <e: Expr> ";" <end:@R> => e,
}

pub Expr: Expr = {
    <e:OperatorExpr> => e,
}

PrimaryTy: Ty = {
    <begin:@L> "bool" <end:@R> => Ty::Bool{span: (begin, end)},
    <begin:@L> "int" <end:@R> => Ty::Int{span: (begin, end)},
    "(" <t: Ty> ")" => t,
}

pub Ty: Ty = {
    #[precedence(level="0")]
    <t: PrimaryTy> => t,
    #[precedence(level="1")] #[assoc(side="right")]
    <begin:@L> <l:Ty> "->" <r:Ty> <end:@R> => Ty::Arrow{
        l: Box::new(l),
        r: Box::new(r),
        span: (begin, end)
    }
}

CommaSepList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
