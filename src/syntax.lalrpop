use crate::ast::{Expr, Ty, BuiltInOp, };
use crate::ast;

grammar;

match {
    // length-2 ops
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "->",
} else {
    // operators
    "+",
    "-",
    "*",
    "/",
    "%",
    "!",
    "=",
    "<",
    ">",
    // brackets
    "(",
    ")",
    "{",
    "}",
    // separators
    ",",
    ";",
    ":",
    ".",
} else {
    r"\d+" => INTLIT,
} else {
    "true",
    "false",
    "lam",
    "bool",
    "int",
    r"\w+" => IDENT,
}

PrimaryExpr: Expr = {
    <begin:@L> <t: IDENT> <end:@R> => Expr::Var{name: String::from(t), span: (begin, end)},
    <begin:@L> <t: INTLIT> <end:@R> => Expr::IntLit{value: t.parse::<i32>().unwrap(), span: (begin, end)},
    <begin:@L> <t: "true"> <end:@R> => Expr::BoolLit{value: t.parse::<bool>().unwrap(), span: (begin, end)},
    <begin:@L> <t: "false"> <end:@R> => Expr::BoolLit{value: t.parse::<bool>().unwrap(), span: (begin, end)},
    "(" <e: Expr> ")" => e,
}

pub Expr: Expr = {
    #[precedence(level="0")]
    <e: PrimaryExpr> => e,

    #[precedence(level="100")]
    #[assoc(side="left")]
    <begin:@L> <func: Expr> <arg: Expr> <end:@R> => Expr::App{
        func: Box::new(func),
        arg: Box::new(arg),
        span: (begin, end)
    },

    #[precedence(level="200")]
    #[assoc(side="left")]
    <begin:@L> <l: Expr> "*" <r: Expr> <end:@R> => Expr::BuiltInOp{
        op: BuiltInOp::Mul,
        l: Box::new(l),
        r: Some(Box::new(r)),
        span: (begin, end)
    },

    #[precedence(level="300")]
    #[assoc(side="left")]
    <begin:@L> <l: Expr> "+" <r: Expr> <end:@R> => Expr::BuiltInOp{
        op: BuiltInOp::Add,
        l: Box::new(l),
        r: Some(Box::new(r)),
        span: (begin, end)
    },

    #[precedence(level="400")]
    #[assoc(side="right")]
    <begin:@L> "lam" <ident: IDENT> ":" <ty: Ty> "." <body: Expr> <end:@R> => Expr::Abs{
        name: String::from(ident),
        ty, 
        body: Box::new(body),
        span: (begin, end)
    },
};

PrimaryTy: Ty = {
    <begin:@L> "bool" <end:@R> => Ty::Bool{span: (begin, end)},
    <begin:@L> "int" <end:@R> => Ty::Int{span: (begin, end)},
    "(" <t: Ty> ")" => t,
}

pub Ty: Ty = {
    #[precedence(level="0")]
    <t: PrimaryTy> => t,
    #[precedence(level="1")] #[assoc(side="right")]
    <begin:@L> <l:Ty> "->" <r:Ty> <end:@R> => Ty::Arrow{
        l: Box::new(l),
        r: Box::new(r),
        span: (begin, end)
    }
}
