use std::fs::File;
use std::io::Write;
use std::path::Path;

const allow_blocks_suffix: &str = "AllowBlocks";
const no_blocks_suffix: &str = "NoBlocks";

fn header() -> String {
    r#"
// ====================================================
// Generated by {src_path}.
// DO NOT EDIT THIS FILE MANUALLY.
// ====================================================

use crate::ast::{Expr, Ty, UnaryOp, BinaryOp, Binding};
use crate::ast;

grammar;

match {
    // length-2 ops
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "->",
} else {
    // operators
    "+",
    "-",
    "*",
    "/",
    "%",
    "!",
    "=",
    "<",
    ">",
    // brackets
    "(",
    ")",
    "{",
    "}",
    // separators
    ",",
    ";",
    ":",
    ".",
} else {
    r"\d+" => INTLIT,
} else {
    "true",
    "false",
    "fn",
    "let",
    "bool",
    "int",
    r"\w+" => IDENT,
}
    "#
    .replace("{src_path}", file!())
    .to_string()
}

fn param() -> String {
    r#"
Param: Binding = {
    <begin:@L> <name: IDENT> <ty: (":" <Ty>)?> <end:@R> => Binding {
        name: String::from(name),
        ty: ty,
        span: (begin, end)
    }
}
    "#
    .to_string()
}

fn fn_expr() -> String {
    r#"
FnExpr: Expr = {
    <begin:@L> "fn" "(" <params: CommaSepList<Param>> ")" <ret_ty: ("->" <Ty>)?> <body:Block> <end:@R> => Expr::Func {
        params: params,
        ret_ty: ret_ty,
        body: Box::new(body),
        span: (begin, end),
    }
}
    "#.to_string()
}

fn block() -> String {
    r#"
Block: Expr = {
    "{" <e: BlockContent> "}" => e 
}
    "#
    .to_string()
}

fn block_content() -> String {
    r##"
BlockContent: Expr = {
    <begin:@L> <mut e: (<Stmt>)*> <r_pos:@R><r: (<OperatorExpr_NoBlocks>)? > <end:@R> => Expr::Seq { 
        seq: {
            if r.is_none() {
                e.push(Expr::UnitLit{span: (r_pos, r_pos)});
            } else {
                e.push(r.unwrap());
            }
            e
        },
        span: (begin, end)
    },
}
    "##
    .to_string()
}

fn primary_expr(allow_block: bool) -> String {
    r##"
PrimaryExpr_{suffix}: Expr = {
    <begin:@L> <t: IDENT> <end:@R> => Expr::Var{name: String::from(t), span: (begin, end)},
    <begin:@L> <t: INTLIT> <end:@R> => Expr::IntLit{value: t.parse::<i32>().unwrap(), span: (begin, end)},
    <begin:@L> <t: "true"> <end:@R> => Expr::BoolLit{value: true, span: (begin, end)},
    <begin:@L> <t: "false"> <end:@R> => Expr::BoolLit{value: false, span: (begin, end)},
    "(" <e: Expr> ")" => e,
    <e:FnExpr> => e,
    {block_clause}
}
"##
.replace("{suffix}", if allow_block {
            allow_blocks_suffix
        } else {
            no_blocks_suffix
        }).replace("{block_clause}", if allow_block {
            "<e: Block> => e"
        } else {
            ""
        })
}

fn operator_expr(allow_block: bool) -> String {
    r##"
pub OperatorExpr_{suffix}: Expr = {
    #[precedence(level="0")]
    <e: PrimaryExpr_{suffix}> => e,

    #[precedence(level="100")]
    <begin:@L> <func: OperatorExpr_{suffix}> "(" <args: CommaSepList<Expr>> ")" <end:@R> => Expr::App{
        func: Box::new(func),
        args: args,
        span: (begin, end)
    },

    #[precedence(level="200")]
    <begin:@L> "+" <arg: OperatorExpr_{suffix}> <end:@R> => Expr::UnaryOp {
        op: UnaryOp::Pos,
        arg: Box::new(arg),
        span: (begin, end)
    },
    <begin:@L> "-" <arg: OperatorExpr_{suffix}> <end:@R> => Expr::UnaryOp {
        op: UnaryOp::Neg,
        arg: Box::new(arg),
        span: (begin, end)
    },

    #[precedence(level="300")]
    #[assoc(side="left")]
    <begin:@L> <arg1: OperatorExpr_{suffix}> "*" <arg2: OperatorExpr_{suffix}> <end:@R> => Expr::BinaryOp {
        op: BinaryOp::Mul,
        arg1: Box::new(arg1),
        arg2: Box::new(arg2),
        span: (begin, end)
    },

    #[precedence(level="400")]
    #[assoc(side="left")]
    <begin:@L> <arg1: OperatorExpr_{suffix}> "+" <arg2: OperatorExpr_{suffix}> <end:@R> => Expr::BinaryOp {
        op: BinaryOp::Add,
        arg1: Box::new(arg1),
        arg2: Box::new(arg2),
        span: (begin, end)
    },
};
"##.replace("{suffix}", if allow_block {
            allow_blocks_suffix
        } else {
            no_blocks_suffix
        })
}

fn let_stmt() -> String {
    r#"
pub LetStmt: Expr = {
    <begin:@L> "let" <name: IDENT> <ty: (":" <Ty>)?> "=" <expr: OperatorExpr_AllowBlocks> ";" <end:@R> => Expr::Let {
        name: name.to_string(),
        ty: ty,
        init: Box::new(expr),
        span: (begin, end)
    },
}
    "#.to_string()
}

fn stmt() -> String {
    r#"
pub Stmt: Expr = {
    <begin:@L> <e: LetStmt> <end:@R> => e,
    <begin:@L> <e: Block> <end:@R> => e,
    <e: OperatorExpr_NoBlocks> ";" <end:@R> => e,
}
    "#
    .to_string()
}

fn expr() -> String {
    r#"
pub Expr: Expr = {
    <e:OperatorExpr_AllowBlocks> => e,
}
    "#
    .to_string()
}

fn primary_ty() -> String {
    r#"
PrimaryTy: Ty = {
    <begin:@L> "bool" <end:@R> => Ty::Bool{span: (begin, end)},
    <begin:@L> "int" <end:@R> => Ty::Int{span: (begin, end)},
    "(" <t: Ty> ")" => t,
}
    "#
    .to_string()
}

fn ty() -> String {
    r#"
pub Ty: Ty = {
    #[precedence(level="0")]
    <t: PrimaryTy> => t,
    #[precedence(level="1")] #[assoc(side="right")]
    <begin:@L> <l:Ty> "->" <r:Ty> <end:@R> => Ty::Arrow{
        l: Box::new(l),
        r: Box::new(r),
        span: (begin, end)
    }
}
    "#
    .to_string()
}

fn comma_sep_list() -> String {
    r#"
CommaSepList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
    "#
    .to_string()
}

pub fn syntax() -> String {
    let mut syntax = String::new();
    syntax.push_str(&header());
    syntax.push_str(&param());
    syntax.push_str(&fn_expr());
    syntax.push_str(&block());
    syntax.push_str(&block_content());
    syntax.push_str(&primary_expr(true));
    syntax.push_str(&primary_expr(false));
    syntax.push_str(&operator_expr(true));
    syntax.push_str(&operator_expr(false));
    syntax.push_str(&let_stmt());
    syntax.push_str(&stmt());
    syntax.push_str(&expr());
    syntax.push_str(&primary_ty());
    syntax.push_str(&ty());
    syntax.push_str(&comma_sep_list());
    syntax
}

pub fn syntax_to_file(path: &str) {
    let mut file = File::create(path).expect("Unable to create file");
    let syntax = syntax();
    file.write_all(syntax.as_bytes())
        .expect("Unable to write data");
}
